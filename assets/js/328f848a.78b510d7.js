"use strict";(self.webpackChunkyearn_devdocs=self.webpackChunkyearn_devdocs||[]).push([[19],{63431:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>d,default:()=>o,frontMatter:()=>i,metadata:()=>l,toc:()=>c});var s=t(74848),r=t(28453);const i={},d="BaseStrategy",l={id:"smart-contracts/V3/BaseStrategy",title:"BaseStrategy",description:"Git Source",source:"@site/docs/developers/smart-contracts/V3/BaseStrategy.md",sourceDirName:"smart-contracts/V3",slug:"/smart-contracts/V3/BaseStrategy",permalink:"/developers/smart-contracts/V3/BaseStrategy",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedAt:1731361534e3,frontMatter:{},sidebar:"developers",previous:{title:"V3 yVault Smart Contracts",permalink:"/developers/smart-contracts/V3/"},next:{title:"TokenizedStrategy",permalink:"/developers/smart-contracts/V3/TokenizedStrategy"}},a={},c=[{value:"State Variables",id:"state-variables",level:2},{value:"tokenizedStrategyAddress",id:"tokenizedstrategyaddress",level:3},{value:"asset",id:"asset",level:3},{value:"TokenizedStrategy",id:"tokenizedstrategy",level:3},{value:"Functions",id:"functions",level:2},{value:"onlySelf",id:"onlyself",level:3},{value:"onlyManagement",id:"onlymanagement",level:3},{value:"onlyKeepers",id:"onlykeepers",level:3},{value:"onlyEmergencyAuthorized",id:"onlyemergencyauthorized",level:3},{value:"_onlySelf",id:"_onlyself",level:3},{value:"constructor",id:"constructor",level:3},{value:"_deployFunds",id:"_deployfunds",level:3},{value:"_freeFunds",id:"_freefunds",level:3},{value:"_harvestAndReport",id:"_harvestandreport",level:3},{value:"_tend",id:"_tend",level:3},{value:"_tendTrigger",id:"_tendtrigger",level:3},{value:"tendTrigger",id:"tendtrigger",level:3},{value:"availableDepositLimit",id:"availabledepositlimit",level:3},{value:"availableWithdrawLimit",id:"availablewithdrawlimit",level:3},{value:"_emergencyWithdraw",id:"_emergencywithdraw",level:3},{value:"deployFunds",id:"deployfunds",level:3},{value:"freeFunds",id:"freefunds",level:3},{value:"harvestAndReport",id:"harvestandreport",level:3},{value:"tendThis",id:"tendthis",level:3},{value:"shutdownWithdraw",id:"shutdownwithdraw",level:3},{value:"_delegateCall",id:"_delegatecall",level:3},{value:"fallback",id:"fallback",level:3}];function h(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"basestrategy",children:"BaseStrategy"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://github.com/yearn/tokenized-strategy/blob/9ef68041bd034353d39941e487499d111c3d3901/src/BaseStrategy.sol",children:"Git Source"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Author:"}),"\nyearn.finance"]}),"\n",(0,s.jsxs)(n.p,{children:["BaseStrategy implements all of the required functionality to\nseamlessly integrate with the ",(0,s.jsx)(n.code,{children:"TokenizedStrategy"})," implementation contract\nallowing anyone to easily build a fully permissionless ERC-4626 compliant\nVault by inheriting this contract and overriding three simple functions.\nIt utilizes an immutable proxy pattern that allows the BaseStrategy\nto remain simple and small. All standard logic is held within the\n",(0,s.jsx)(n.code,{children:"TokenizedStrategy"})," and is reused over any n strategies all using the\n",(0,s.jsx)(n.code,{children:"fallback"})," function to delegatecall the implementation so that strategists\ncan only be concerned with writing their strategy specific code.\nThis contract should be inherited and the three main abstract methods\n",(0,s.jsx)(n.code,{children:"_deployFunds"}),", ",(0,s.jsx)(n.code,{children:"_freeFunds"})," and ",(0,s.jsx)(n.code,{children:"_harvestAndReport"})," implemented to adapt\nthe Strategy to the particular needs it has to generate yield. There are\nother optional methods that can be implemented to further customize\nthe strategy if desired.\nAll default storage for the strategy is controlled and updated by the\n",(0,s.jsx)(n.code,{children:"TokenizedStrategy"}),". The implementation holds a storage struct that\ncontains all needed global variables in a manual storage slot. This\nmeans strategists can feel free to implement their own custom storage\nvariables as they need with no concern of collisions. All global variables\ncan be viewed within the Strategy by a simple call using the\n",(0,s.jsx)(n.code,{children:"TokenizedStrategy"})," variable. IE: TokenizedStrategy.globalVariable();."]}),"\n",(0,s.jsx)(n.h2,{id:"state-variables",children:"State Variables"}),"\n",(0,s.jsx)(n.h3,{id:"tokenizedstrategyaddress",children:"tokenizedStrategyAddress"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"This is the address of the TokenizedStrategy implementation\ncontract that will be used by all strategies to handle the\naccounting, logic, storage etc.\nAny external calls to the that don't hit one of the functions\ndefined in this base or the strategy will end up being forwarded\nthrough the fallback function, which will delegateCall this address.\nThis address should be the same for every strategy, never be adjusted\nand always be checked before any integration with the Strategy."})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:"address public constant tokenizedStrategyAddress = 0x2e234DAe75C793f67A35089C9d99245E1C58470b;\n"})}),"\n",(0,s.jsx)(n.h3,{id:"asset",children:"asset"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"Underlying asset the Strategy is earning yield on.\nStored here for cheap retrievals within the strategy."})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:"ERC20 internal immutable asset;\n"})}),"\n",(0,s.jsx)(n.h3,{id:"tokenizedstrategy",children:"TokenizedStrategy"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"This variable is set to address(this) during initialization of each strategy.\nThis can be used to retrieve storage data within the strategy\ncontract as if it were a linked library.\ni.e. uint256 totalAssets = TokenizedStrategy.totalAssets()\nUsing address(this) will mean any calls using this variable will lead\nto a call to itself. Which will hit the fallback function and\ndelegateCall that to the actual TokenizedStrategy."})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:"ITokenizedStrategy internal immutable TokenizedStrategy;\n"})}),"\n",(0,s.jsx)(n.h2,{id:"functions",children:"Functions"}),"\n",(0,s.jsx)(n.h3,{id:"onlyself",children:"onlySelf"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"Used on TokenizedStrategy callback functions to make sure it is post\na delegateCall from this address to the TokenizedStrategy."})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:"modifier onlySelf();\n"})}),"\n",(0,s.jsx)(n.h3,{id:"onlymanagement",children:"onlyManagement"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"Use to assure that the call is coming from the strategies management."})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:"modifier onlyManagement();\n"})}),"\n",(0,s.jsx)(n.h3,{id:"onlykeepers",children:"onlyKeepers"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"Use to assure that the call is coming from either the strategies\nmanagement or the keeper."})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:"modifier onlyKeepers();\n"})}),"\n",(0,s.jsx)(n.h3,{id:"onlyemergencyauthorized",children:"onlyEmergencyAuthorized"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"Use to assure that the call is coming from either the strategies\nmanagement or the emergency admin."})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:"modifier onlyEmergencyAuthorized();\n"})}),"\n",(0,s.jsx)(n.h3,{id:"_onlyself",children:"_onlySelf"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"Require that the msg.sender is this address."})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:"function _onlySelf() internal view;\n"})}),"\n",(0,s.jsx)(n.h3,{id:"constructor",children:"constructor"}),"\n",(0,s.jsxs)(n.p,{children:["Used to initialize the strategy on deployment.\nThis will set the ",(0,s.jsx)(n.code,{children:"TokenizedStrategy"})," variable for easy\ninternal view calls to the implementation. As well as\ninitializing the default storage variables based on the\nparameters and using the deployer for the permissioned roles."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:"constructor(address _asset, string memory _name);\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Parameters"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Name"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"_asset"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"address"})}),(0,s.jsx)(n.td,{children:"Address of the underlying asset."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"_name"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"string"})}),(0,s.jsx)(n.td,{children:"Name the strategy will use."})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"_deployfunds",children:"_deployFunds"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsxs)(n.em,{children:["Can deploy up to '_amount' of 'asset' in the yield source.\nThis function is called at the end of a ",(0,s.jsx)(n.code,{children:"deposit"})," or ",(0,s.jsx)(n.code,{children:"mint"}),"\ncall. Meaning that unless a whitelist is implemented it will\nbe entirely permissionless and thus can be sandwiched or otherwise\nmanipulated."]})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:"function _deployFunds(uint256 _amount) internal virtual;\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Parameters"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Name"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"_amount"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"uint256"})}),(0,s.jsx)(n.td,{children:"The amount of 'asset' that the strategy can attempt to deposit in the yield source."})]})})]}),"\n",(0,s.jsx)(n.h3,{id:"_freefunds",children:"_freeFunds"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsxs)(n.em,{children:["Should attempt to free the '_amount' of 'asset'.\nNOTE: The amount of 'asset' that is already loose has already\nbeen accounted for.\nThis function is called during ",(0,s.jsx)(n.code,{children:"withdraw"})," and ",(0,s.jsx)(n.code,{children:"redeem"})," calls.\nMeaning that unless a whitelist is implemented it will be\nentirely permissionless and thus can be sandwiched or otherwise\nmanipulated.\nShould not rely on asset.balanceOf(address(this)) calls other than\nfor diff accounting purposes.\nAny difference between ",(0,s.jsx)(n.code,{children:"_amount"})," and what is actually freed will be\ncounted as a loss and passed on to the withdrawer. This means\ncare should be taken in times of illiquidity. It may be better to revert\nif withdraws are simply illiquid so not to realize incorrect losses."]})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:"function _freeFunds(uint256 _amount) internal virtual;\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Parameters"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Name"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"_amount"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"uint256"})}),(0,s.jsx)(n.td,{})]})})]}),"\n",(0,s.jsx)(n.h3,{id:"_harvestandreport",children:"_harvestAndReport"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsxs)(n.em,{children:["Internal function to harvest all rewards, redeploy any idle\nfunds and return an accurate accounting of all funds currently\nheld by the Strategy.\nThis should do any needed harvesting, rewards selling, accrual,\nredepositing etc. to get the most accurate view of current assets.\nNOTE: All applicable assets including loose assets should be\naccounted for in this function.\nCare should be taken when relying on oracles or swap values rather\nthan actual amounts as all Strategy profit/loss accounting will\nbe done based on this returned value.\nThis can still be called post a shutdown, a strategist can check\n",(0,s.jsx)(n.code,{children:"TokenizedStrategy.isShutdown()"})," to decide if funds should be\nredeployed or simply realize any profits/losses."]})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:"function _harvestAndReport() internal virtual returns (uint256 _totalAssets);\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Returns"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Name"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"_totalAssets"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"uint256"})}),(0,s.jsx)(n.td,{children:"A trusted and accurate account for the total amount of 'asset' the strategy currently holds including idle funds."})]})})]}),"\n",(0,s.jsx)(n.h3,{id:"_tend",children:"_tend"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"Optional function for strategist to override that can\nbe called in between reports.\nIf '_tend' is used tendTrigger() will also need to be overridden.\nThis call can only be called by a permissioned role so may be\nthrough protected relays.\nThis can be used to harvest and compound rewards, deposit idle funds,\nperform needed position maintenance or anything else that doesn't need\na full report for.\nEX: A strategy that can not deposit funds without getting\nsandwiched can use the tend when a certain threshold\nof idle to totalAssets has been reached.\nThis will have no effect on PPS of the strategy till report() is called."})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:"function _tend(uint256 _totalIdle) internal virtual;\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Parameters"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Name"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"_totalIdle"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"uint256"})}),(0,s.jsx)(n.td,{children:"The current amount of idle funds that are available to deploy."})]})})]}),"\n",(0,s.jsx)(n.h3,{id:"_tendtrigger",children:"_tendTrigger"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"Optional trigger to override if tend() will be used by the strategy.\nThis must be implemented if the strategy hopes to invoke _tend()."})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:"function _tendTrigger() internal view virtual returns (bool);\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Returns"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Name"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"<none>"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"bool"})}),(0,s.jsx)(n.td,{children:". Should return true if tend() should be called by keeper or false if not."})]})})]}),"\n",(0,s.jsx)(n.h3,{id:"tendtrigger",children:"tendTrigger"}),"\n",(0,s.jsx)(n.p,{children:"Returns if tend() should be called by a keeper."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:"function tendTrigger() external view virtual returns (bool, bytes memory);\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Returns"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Name"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"<none>"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"bool"})}),(0,s.jsx)(n.td,{children:". Should return true if tend() should be called by keeper or false if not."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"<none>"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"bytes"})}),(0,s.jsx)(n.td,{children:". Calldata for the tend call."})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"availabledepositlimit",children:"availableDepositLimit"}),"\n",(0,s.jsxs)(n.p,{children:["Gets the max amount of ",(0,s.jsx)(n.code,{children:"asset"})," that an address can deposit."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsxs)(n.em,{children:["Defaults to an unlimited amount for any address. But can\nbe overridden by strategists.\nThis function will be called before any deposit or mints to enforce\nany limits desired by the strategist. This can be used for either a\ntraditional deposit limit or for implementing a whitelist etc.\nEX:\nif(isAllowed[_owner]) return super.availableDepositLimit(_owner);\nThis does not need to take into account any conversion rates\nfrom shares to assets. But should know that any non max uint256\namounts may be converted to shares. So it is recommended to keep\ncustom amounts low enough as not to cause overflow when multiplied\nby ",(0,s.jsx)(n.code,{children:"totalSupply"}),"."]})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:"function availableDepositLimit(address) public view virtual returns (uint256);\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Parameters"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Name"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"<none>"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"address"})}),(0,s.jsx)(n.td,{})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Returns"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Name"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"<none>"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"uint256"})}),(0,s.jsxs)(n.td,{children:[". The available amount the ",(0,s.jsx)(n.code,{children:"_owner"})," can deposit in terms of ",(0,s.jsx)(n.code,{children:"asset"})]})]})})]}),"\n",(0,s.jsx)(n.h3,{id:"availablewithdrawlimit",children:"availableWithdrawLimit"}),"\n",(0,s.jsxs)(n.p,{children:["Gets the max amount of ",(0,s.jsx)(n.code,{children:"asset"})," that can be withdrawn."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsxs)(n.em,{children:["Defaults to an unlimited amount for any address. But can\nbe overridden by strategists.\nThis function will be called before any withdraw or redeem to enforce\nany limits desired by the strategist. This can be used for illiquid\nor sandwichable strategies. It should never be lower than ",(0,s.jsx)(n.code,{children:"totalIdle"}),".\nEX:\nreturn TokenIzedStrategy.totalIdle();\nThis does not need to take into account the ",(0,s.jsx)(n.code,{children:"_owner"}),"'s share balance\nor conversion rates from shares to assets."]})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:"function availableWithdrawLimit(address) public view virtual returns (uint256);\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Parameters"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Name"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"<none>"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"address"})}),(0,s.jsx)(n.td,{})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Returns"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Name"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"<none>"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"uint256"})}),(0,s.jsxs)(n.td,{children:[". The available amount that can be withdrawn in terms of ",(0,s.jsx)(n.code,{children:"asset"})]})]})})]}),"\n",(0,s.jsx)(n.h3,{id:"_emergencywithdraw",children:"_emergencyWithdraw"}),"\n",(0,s.jsxs)(n.p,{children:["*Optional function for a strategist to override that will\nallow management to manually withdraw deployed funds from the\nyield source if a strategy is shutdown.\nThis should attempt to free ",(0,s.jsx)(n.code,{children:"_amount"}),", noting that ",(0,s.jsx)(n.code,{children:"_amount"})," may\nbe more than is currently deployed.\nNOTE: This will not realize any profits or losses. A separate\n",(0,s.jsx)(n.code,{children:"report"})," will be needed in order to record any profit/loss. If\na report may need to be called after a shutdown it is important\nto check if the strategy is shutdown during ",(0,s.jsx)(n.code,{children:"_harvestAndReport"}),"\nso that it does not simply re-deploy all funds that had been freed."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",metastring:'title="Example"',children:"if(freeAsset > 0 && !TokenizedStrategy.isShutdown()) {\ndepositFunds...\n}\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:"function _emergencyWithdraw(uint256 _amount) internal virtual;\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Parameters"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Name"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"_amount"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"uint256"})}),(0,s.jsx)(n.td,{children:"The amount of asset to attempt to free."})]})})]}),"\n",(0,s.jsx)(n.h3,{id:"deployfunds",children:"deployFunds"}),"\n",(0,s.jsx)(n.p,{children:"Can deploy up to '_amount' of 'asset' in yield source."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsxs)(n.em,{children:["Callback for the TokenizedStrategy to call during a ",(0,s.jsx)(n.code,{children:"deposit"}),"\nor ",(0,s.jsx)(n.code,{children:"mint"})," to tell the strategy it can deploy funds.\nSince this can only be called after a ",(0,s.jsx)(n.code,{children:"deposit"})," or ",(0,s.jsx)(n.code,{children:"mint"}),"\ndelegateCall to the TokenizedStrategy msg.sender == address(this).\nUnless a whitelist is implemented this will be entirely permissionless\nand thus can be sandwiched or otherwise manipulated."]})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:"function deployFunds(uint256 _amount) external virtual onlySelf;\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Parameters"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Name"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"_amount"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"uint256"})}),(0,s.jsx)(n.td,{children:"The amount of 'asset' that the strategy can attempt to deposit in the yield source."})]})})]}),"\n",(0,s.jsx)(n.h3,{id:"freefunds",children:"freeFunds"}),"\n",(0,s.jsx)(n.p,{children:"Should attempt to free the '_amount' of 'asset'."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"Callback for the TokenizedStrategy to call during a withdraw\nor redeem to free the needed funds to service the withdraw.\nThis can only be called after a 'withdraw' or 'redeem' delegateCall\nto the TokenizedStrategy so msg.sender == address(this)."})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:"function freeFunds(uint256 _amount) external virtual onlySelf;\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Parameters"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Name"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"_amount"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"uint256"})}),(0,s.jsx)(n.td,{children:"The amount of 'asset' that the strategy should attempt to free up."})]})})]}),"\n",(0,s.jsx)(n.h3,{id:"harvestandreport",children:"harvestAndReport"}),"\n",(0,s.jsx)(n.p,{children:"Returns the accurate amount of all funds currently\nheld by the Strategy."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"Callback for the TokenizedStrategy to call during a report to\nget an accurate accounting of assets the strategy controls.\nThis can only be called after a report() delegateCall to the\nTokenizedStrategy so msg.sender == address(this)."})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:"function harvestAndReport() external virtual onlySelf returns (uint256);\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Returns"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Name"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"<none>"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"uint256"})}),(0,s.jsx)(n.td,{children:". A trusted and accurate account for the total amount of 'asset' the strategy currently holds including idle funds."})]})})]}),"\n",(0,s.jsx)(n.h3,{id:"tendthis",children:"tendThis"}),"\n",(0,s.jsx)(n.p,{children:"Will call the internal '_tend' when a keeper tends the strategy."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsxs)(n.em,{children:["Callback for the TokenizedStrategy to initiate a _tend call in the strategy.\nThis can only be called after a tend() delegateCall to the TokenizedStrategy\nso msg.sender == address(this).\nWe name the function ",(0,s.jsx)(n.code,{children:"tendThis"})," so that ",(0,s.jsx)(n.code,{children:"tend"})," calls are forwarded to\nthe TokenizedStrategy."]})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:"function tendThis(uint256 _totalIdle) external virtual onlySelf;\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Parameters"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Name"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"_totalIdle"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"uint256"})}),(0,s.jsx)(n.td,{children:"The amount of current idle funds that can be deployed during the tend"})]})})]}),"\n",(0,s.jsx)(n.h3,{id:"shutdownwithdraw",children:"shutdownWithdraw"}),"\n",(0,s.jsx)(n.p,{children:"Will call the internal '_emergencyWithdraw' function."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsxs)(n.em,{children:["Callback for the TokenizedStrategy during an emergency withdraw.\nThis can only be called after a emergencyWithdraw() delegateCall to\nthe TokenizedStrategy so msg.sender == address(this).\nWe name the function ",(0,s.jsx)(n.code,{children:"shutdownWithdraw"})," so that ",(0,s.jsx)(n.code,{children:"emergencyWithdraw"}),"\ncalls are forwarded to the TokenizedStrategy."]})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:"function shutdownWithdraw(uint256 _amount) external virtual onlySelf;\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Parameters"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Name"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"_amount"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"uint256"})}),(0,s.jsx)(n.td,{children:"The amount of asset to attempt to free."})]})})]}),"\n",(0,s.jsx)(n.h3,{id:"_delegatecall",children:"_delegateCall"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsxs)(n.em,{children:["Function used to delegate call the TokenizedStrategy with\ncertain ",(0,s.jsx)(n.code,{children:"_calldata"})," and return any return values.\nThis is used to setup the initial storage of the strategy, and\ncan be used by strategist to forward any other call to the\nTokenizedStrategy implementation."]})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:"function _delegateCall(bytes memory _calldata) internal returns (bytes memory);\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Parameters"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Name"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"_calldata"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"bytes"})}),(0,s.jsx)(n.td,{children:"The abi encoded calldata to use in delegatecall."})]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Returns"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Name"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"<none>"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"bytes"})}),(0,s.jsx)(n.td,{children:". The return value if the call was successful in bytes."})]})})]}),"\n",(0,s.jsx)(n.h3,{id:"fallback",children:"fallback"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"Execute a function on the TokenizedStrategy and return any value.\nThis fallback function will be executed when any of the standard functions\ndefined in the TokenizedStrategy are called since they wont be defined in\nthis contract.\nIt will delegatecall the TokenizedStrategy implementation with the exact\ncalldata and return any relevant values."})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:"fallback() external;\n"})})]})}function o(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>d,x:()=>l});var s=t(96540);const r={},i=s.createContext(r);function d(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:d(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);